# Unlock the power of modern Java, by Jesper Udby

[JCafe](https://javagruppen.dk/2025/04/08/unlock-power-java.html) Tirsdag 8. april kl 17

Lad os mødes til en hyggelig JCafe med Virtual Threads, Foreign Function Memory og Structured concurrency hos
[Sopra Steria](https://www.soprasteria.dk/) den 8/4 kl 17:00 - 18:30.

## Dagsorden

* [Introduktion, om Jesper](#introduktion-om-jesper)
* [Virtual Threads](#virtual-threads)
* [Foreign Function and Memory API (FFM)](#foreign-function-and-memory-api-ffm)
* [Structured Concurrency (preview)](#structured-concurrency-preview)
* _Bonus (hvis tiden tillader):_ [Double-checking locking vs StableValue (Java 25)](#double-checking-locking-vs-stablevalue-java-25)

Link til denne præsentation:  
![Scan me QR code](qr.png)

## Introduktion, Om Jesper

* Jesper Udby, 56 år gammel, gift med Mette siden 1996
* Uddannet civilingeniør, svagstrøm
* JAVA som primær programmeringssprog siden 1998
* Freelance konsulent siden 2001
* Hænger gerne ud på konferencer, f.eks.
  - [jChampions Conference](https://jchampionsconf.com/) - Virtuel
  - [Jfokus](https://jfokus.se/) - Stockholm, februar
  - [JChateau](https://www.jchateau.org/) - Frankrig, marts
  - [JAlba](https://jalba.scot/) - Edinburgh, maj
* Laver forresten også [bankoplader](https://bankopladerne.dk/)... 

![Jesper Udby](profilbillede.png)

## Virtual Threads

[Virtual threads](https://openjdk.org/jeps/444) er ny feature som er ude af preview fra Java-21. Oracle skriver:

> ### What is a Virtual Thread?
> Like a platform thread, a virtual thread is also an instance of `java.lang.Thread`. 
> However, a virtual thread isn't tied to a specific OS thread. A virtual thread still runs code on an OS thread. _However, when code running in a virtual thread calls a **blocking I/O operation**_, the Java runtime suspends the virtual thread until it can be resumed.
> The OS thread associated with the suspended virtual thread is now free to perform operations for other virtual threads.
>
> Virtual threads are implemented in a similar way to virtual memory. 
> To simulate a lot of memory, an operating system maps a large virtual address space to a limited amount of RAM.
> Similarly, to simulate a lot of threads, the Java runtime maps a large number of virtual threads to a small number of OS threads.
>
> Unlike platform threads, virtual threads typically have a shallow call stack, performing as few as a single _HTTP client call or a single JDBC query_.
> Although virtual threads support thread-local variables and inheritable thread-local variables, you should carefully consider using them because a single JVM might support millions of virtual threads.
>
> Virtual threads are suitable for running tasks that _spend most of the time blocked_, often waiting for I/O operations to complete. _**However, they aren't intended for long-running CPU-intensive operations.**_

* Giver mening ved "blocking I/O operations"
* Duer ikke ved "long-running CPU-intensive operations"

_There is no magic :-)_: En Quad-core CPU med hyperthreading kan løse 8 samtidige uafhængige opgaver, det bliver ikke anderledes med virtuelle tråde:

> ### Why Use Virtual Threads?
> Use virtual threads in high-throughput concurrent applications, especially those that consist of a great number of concurrent tasks that _spend much of their time waiting_.
> 
> Server applications are examples of high-throughput applications because they typically handle many client requests that perform _blocking I/O operations_ such as fetching resources.
>
> _Virtual threads are **not faster threads**; they do not run code any faster than platform threads. They exist to provide **scale (higher throughput), not speed (lower latency).**_

* Løser primært problemet ved behandling af forespørgsler i "backend" hvor én forespørgsel knyttes til én tråd
  - 1000 samtidige forspørgsler bliver til 1000 plaformtråde
  - Default stack størrelse på platform tråd er 1MiB => 1GiB alene til stack, desuden kommer scheduleren på overarbejde
  - Virtuelle tråde har en "shallow" stack som JVM'en kan flytte til heap når tråden blokeres... -ish ;-)
  - Bruger ikke operativ-system resourcer, knyttes til en carrier-tråd (common fork-join pool) når aktiv
* Træerne vokser ikke ind i himlen
  - Brug af `synchronized` eller `native` kald (herunder JNI og "Foreign function calls" fra FFM) kan betyde "pinning" og forhindrer virtuelle tråde i at blive "unmounted" fra carrier tråden
  - Fil-system I/O blokerer stadig (det fremgår måske ikke så tydeligt...)
  - Undgå brugen af `ThreadLocal` - men det bør man jo altid ;-) Nyere alternativ til `ThreadLocal`s er ["Scoped Values"](https://openjdk.org/jeps/487) dog stadig preview i Java-24

> Pinning does not make an application incorrect, but it might hinder its scalability. 
> Try avoiding frequent and long-lived pinning by revising `synchronized` blocks or methods that run frequently and 
> guarding potentially long I/O operations with `java.util.concurrent.locks.ReentrantLock`.

**Java-24** [forbedrer situationen ved "pinning" i forbindelse med `synchronized`](https://openjdk.org/jeps/491), lider stadig under fil-system I/O blocking og native kald.

Heinz skriver også lidt om Virtual Threads f.eks: [Gazillion Virtual Threads](https://www.javaspecialists.eu/archive/Issue301-Gazillion-Virtual-Threads.html).

### How-to

#### Executors

```java
try (final var executorService = Executors.newVirtualThreadPerTaskExecutor()) {
    executorService.execute(() -> {
        // Important stuff going to block on I/O...
    });
}
```

#### Thread

```java
Thread.ofVirtual().start(() -> {
    // Important stuff going to block on I/O...
});
```

## Foreign Function and Memory API (FFM)

[Foreign Function and Memory API](https://openjdk.org/jeps/454) er nye features som er ude af preview fra [Java-23](https://docs.oracle.com/en/java/javase/23/core/foreign-function-and-memory-api.html.

Der er dybest set tale om to meget forskellige områder, som dog hænger tæt sammen. Kan bruges hver for sig:

* [Memory access (M)](#memory-access)
* [Foreign function calls (FF)](#foreign-function-calls)

### Memory access

FFM introducerer et [`Areana`](https://docs.oracle.com/en/java/javase/23/docs/api/java.base/java/lang/foreign/Arena.html) begreb som dækker over forskellige typer off-heap hukommelse:

* Global ([`Arena.global()`](https://docs.oracle.com/en/java/javase/23/docs/api/java.base/java/lang/foreign/Arena.html#global())) - allokeret hukommelse kan tilgås fra alle tråde, bliver aldrig deallokeret...
* Auto ([`Arena.ofAuto()`](https://docs.oracle.com/en/java/javase/23/docs/api/java.base/java/lang/foreign/Arena.html#ofAuto())) - allokeret hukommelse kan tilgås fra alle tråde, bliver deallokeret af garbage-collector.
* Confined ([`Arena.ofConfined()`](https://docs.oracle.com/en/java/javase/23/docs/api/java.base/java/lang/foreign/Arena.html#ofConfined())) - allokeret hukommelse kan tilgås fra tråden som "ejer", bliver deallokeret ved `arena.close()`.
* Shared ([`Arena.ofShared()`](https://docs.oracle.com/en/java/javase/23/docs/api/java.base/java/lang/foreign/Arena.html#ofShared())) - allokeret hukommelse kan tilgås fra alle tråde, bliver deallokeret ved `arena.close()`.

Off-heap hukommelse kan bruges af applikationer som har behov for at styre hukommelse uden involvering af garbage-collector, herunder mapping af vilkårligt store filer og ved brug af native kald.

#### Eksempel

Allokerer hukommelse til brug for kørende tråd, automatisk frigivelse af alt allokeret off-heap hukommelse ved `close()` (try-with-resources):

```java
try (final var arena = Arena.ofConfined()) {
    final var memorySegment = arena.allocate(1_000_000_000L);
    // do stuff with memorySegment
}
``` 

### Foreign Function calls

Foreign function calls delen giver mulighed for at kalde "native" kode, f.eks C-biblioteker, med et mere moderne API end JNI eller JNA.

Omkostningen ved at krydse JAVA-native "barrier" skulle være lavere end med JNI/JNA og med hjælp fra [Memory access](#memory-access) delen er det nemmere at dele off-heap strukturer mellem JAVA- og native verden, 
hviklet blandet andet minimerer risiko for memory-leaks og "wild-pointer" access.

Se f.eks Oracles eksempel på kald af C `strlen()` fra JAVA: [Calling a C Library Function with the Foreign Function and Memory API](https://docs.oracle.com/en/java/javase/23/core/calling-c-library-function-foreign-function-and-memory-api.html)




## Structured Concurrency (preview)

### Demo: Large File Split, S3 integration

## Double-checking locking vs StableValue (Java 25)

